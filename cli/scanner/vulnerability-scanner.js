import ora from 'ora';
import chalk from 'chalk';
import { Crawler } from './crawler.js';
import { VulnerabilityDetector } from './detectors/vulnerability-detector.js';
import { ScreenshotCapture } from './screenshot-capture.js';
import { AIAnalyzer } from '../ai/ai-analyzer.js';
import { MLEngine } from '../ai/ml-engine.js';

export class VulnerabilityScanner {
  constructor(database, options = {}) {
    this.db = database;
    this.options = {
      depth: options.depth || 3,
      screenshots: options.screenshots !== false,
      aiAnalysis: options.aiAnalysis || false,
      threads: options.threads || 5
    };

    this.crawler = new Crawler(this.options);
    this.detector = new VulnerabilityDetector();
    this.screenshotCapture = this.options.screenshots ? new ScreenshotCapture() : null;
    this.aiAnalyzer = this.options.aiAnalysis ? new AIAnalyzer() : null;
    this.mlEngine = new MLEngine(this.db);
  }

  async scan(targetUrl) {
    const scanId = this.db.createScan(targetUrl);
    const results = {
      scanId,
      targetUrl,
      timestamp: new Date().toISOString(),
      endpoints: [],
      vulnerabilities: [],
      statistics: {},
      aiAnalysis: null
    };

    try {
      await this.screenshotCapture?.initialize();

      const crawlSpinner = ora('üï∑Ô∏è  Crawling target and discovering endpoints...').start();
      const endpoints = await this.crawler.crawl(targetUrl);
      results.endpoints = endpoints;
      crawlSpinner.succeed(chalk.green(`Found ${endpoints.length} endpoints`));

      const scanSpinner = ora('üîç Scanning for vulnerabilities...').start();
      const vulnerabilities = [];

      for (let i = 0; i < endpoints.length; i++) {
        const endpoint = endpoints[i];
        scanSpinner.text = `Scanning ${i + 1}/${endpoints.length}: ${endpoint.url}`;

        const vulns = await this.detector.detectVulnerabilities(endpoint);

        for (const vuln of vulns) {
          if (this.screenshotCapture) {
            try {
              vuln.screenshotPath = await this.screenshotCapture.capture(
                vuln.url,
                `vuln_${vuln.type}_${Date.now()}`
              );
            } catch (err) {
              vuln.screenshotPath = null;
            }
          }

          vuln.mlConfidence = await this.mlEngine.predictConfidence(vuln);

          vulnerabilities.push(vuln);
          this.db.saveVulnerability(scanId, vuln);
        }
      }

      results.vulnerabilities = vulnerabilities;
      scanSpinner.succeed(chalk.green(`Scan complete - ${vulnerabilities.length} vulnerabilities found`));

      if (this.aiAnalyzer && vulnerabilities.length > 0) {
        const aiSpinner = ora('ü§ñ Performing AI-powered analysis...').start();
        results.aiAnalysis = await this.aiAnalyzer.analyze(results);
        aiSpinner.succeed(chalk.green('AI analysis complete'));
      }

      const mlSpinner = ora('üß† Training ML models with scan data...').start();
      await this.mlEngine.trainOnScanResults(results);
      mlSpinner.succeed(chalk.green('ML models updated'));

      results.statistics = this.calculateStatistics(results);
      this.db.updateScan(scanId, results);

      await this.screenshotCapture?.close();

      return results;

    } catch (error) {
      this.db.updateScan(scanId, { error: error.message });
      await this.screenshotCapture?.close();
      throw error;
    }
  }

  calculateStatistics(results) {
    const stats = {
      totalEndpoints: results.endpoints.length,
      totalVulnerabilities: results.vulnerabilities.length,
      bySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      byType: {}
    };

    results.vulnerabilities.forEach(vuln => {
      stats.bySeverity[vuln.severity.toLowerCase()]++;
      stats.byType[vuln.type] = (stats.byType[vuln.type] || 0) + 1;
    });

    return stats;
  }
}
